//! Rust code generation given abstract packet structure.

use std::{fmt::Write, fs};

use crate::parse::Packet;

mod opcodes;
mod packets;

pub fn write_packets(packets: &[Packet], dst: &str) -> anyhow::Result<()> {
    let mut output = String::new();
    packets::emit(&mut output, &packets)?;
    let output = rustfmt(&output)?;
    fs::write(dst, output)?;

    Ok(())
}

pub fn write_opcodes(packets: &[Packet], dst: &str) -> anyhow::Result<()> {
    let mut opcodes = String::new();
    opcodes::emit(&mut opcodes, &packets)?;
    let opcodes = rustfmt(&opcodes)?;
    fs::write(dst, opcodes)?;

    Ok(())
}

fn rustfmt(code: &str) -> anyhow::Result<String> {
    use std::io::Write as _;
    use std::process::{Command, Stdio};
    let mut child = Command::new("rustfmt")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .unwrap();
    child.stdin.take().unwrap().write_all(code.as_bytes())?;
    let out = child.wait_with_output()?;
    let formatted_code = String::from_utf8(out.stdout)?;
    Ok(formatted_code)
}

fn emit_notice(w: &mut impl Write) -> anyhow::Result<()> {
    w.write_str("// NOTE: This file is automatically generated.\n\n")?;
    Ok(())
}
